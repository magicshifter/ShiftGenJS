<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Magicshifter JS Sim</title>
		<style>
			body {
			background: #333;
			}
		</style>
		<script type="text/javascript" src="libs/snap.svg-min.js"></script>
        <script type="text/javascript" src="libs/dat.gui.min.js"></script>
        <script type="text/javascript" src="libs/three.js"></script>
        <script type="text/javascript" src="libs/Colour.js"></script>
        <script type="text/javascript" src="libs/FileSaver.js"></script>
    </head>
	<body>

    <textarea id="svgSource" style="position: fixed; bottom: 0px; left: 0px; "></textarea>

    <script>
/*
            var paper = Raphael("canvas", 640, 480);

            // Creates circle at x = 50, y = 40, with radius 10
            var circle = paper.circle(50, 40, 10);
            // Sets the fill attribute of the circle to red (#f00)
            circle.attr("fill", "#f00");

            // Sets the stroke attribute of the circle to white
            circle.attr("stroke", "#fff");
            return;
*/
            var width = window.innerWidth;
            var height = window.innerHeight;
            var s = Snap(width, height);

            var simState = {
                steps: 50,
                startStep: 0,

                axisX: 0.1,
                axisY: 0.9,
                axisZ: 0.11,

                startX: -100,
                startY: 0,
                startZ: 200,

                shifterDirX: 0,
                shifterDirY: 10,
                shifterDirZ: 0,

                transX: 0.01,
                transY: 0.01,
                transZ: 0.01,

                rotSpeed: 0.035,
                save: function() {
                    var svgText = s.outerSVG();
                    var svgBlob = new Blob([svgText], {type: "image/svg+xml"});
                    saveAs(svgBlob, "export.svg");
                    document.getElementById("svgSource").value = svgText;
                },
            };

            var gui = new dat.GUI();

            function SetupOnChange(controller) {
                controller.onChange(function(value) {
                    // Fires on every change, drag, keypress, etc.
                    DoSim();
                });

//                controller.onFinishChange(function(value) {
//                    // Fires when a controller loses focus.
//                    alert("The new value is " + value);
//                });
            }

            SetupOnChange(gui.add(simState, 'steps', 1, 350));
            SetupOnChange(gui.add(simState, 'startStep', 0, 249));

            SetupOnChange(gui.add(simState, 'axisX', -1, 1));
            SetupOnChange(gui.add(simState, 'axisY', -1, 1));
            SetupOnChange(gui.add(simState, 'axisZ', -1, 1));

            SetupOnChange(gui.add(simState, 'startX', -500, 500));
            SetupOnChange(gui.add(simState, 'startY', -500, 500));
            SetupOnChange(gui.add(simState, 'startZ', -500, 500));

            SetupOnChange(gui.add(simState, 'shifterDirX', -10, 10));
            SetupOnChange(gui.add(simState, 'shifterDirY', -10, 10));
            SetupOnChange(gui.add(simState, 'shifterDirZ', -10, 10));

            SetupOnChange(gui.add(simState, 'transX', -10, 10));
            SetupOnChange(gui.add(simState, 'transY', -10, 10));
            SetupOnChange(gui.add(simState, 'transZ', -10, 10));

            SetupOnChange(gui.add(simState, 'rotSpeed', 0, 0.05));
            gui.add(simState, 'save');



            // initial run
            DoSim();

//saving
//$("#code-block").text(s.outerSVG());

            function DoSim() {
                s.clear();

                var LEDS = 16;
                var ledPositions = [];
                var tempPositions = [];

                var pos = new THREE.Vector4(simState.startX, simState.startY, simState.startZ, 1);
                var dir = new THREE.Vector4(simState.shifterDirX, simState.shifterDirY, simState.shifterDirZ, 0);

                for (var i = 0; i < LEDS; i++) {
                    var newPos = dir.clone();
                    newPos.multiplyScalar(i);
                    newPos.add(pos);

                    ledPositions[i] = newPos;
                    tempPositions[i] = ledPositions[i];
                }

                var axis = new THREE.Vector3(simState.axisX, simState.axisY, simState.axisZ);
                axis.normalize();
                var m = new THREE.Matrix4();
                m.makeRotationAxis(axis, simState.rotSpeed);
                var t = new THREE.Matrix4();
                t.makeTranslation(simState.transX, simState.transY, simState.transZ);
                m.multiply(t);

                for (var step = 0; step < simState.steps; step++) {
                    for (var i = 0; i < LEDS; i++) {
                        var v = tempPositions[i];

                        // show it if start is invalid or if its in range
                        if (simState.startStep >= simState.steps ||
                            step >= simState.startStep) {
                            var color = new HSVColour((360 * Math.sin(step / 40)) % 360, 100, 100);
                            var ledCirc = s.circle(v.x + width/2, v.y + height/2, 2);
                            ledCirc.attr({
                                fill: color.getCSSHexadecimalRGB(),
                                stroke: "#000",
                                strokeWidth: 1
                            });
                        }

                        vT = v.clone();
                        vT.applyMatrix4(m);
                        tempPositions[i] = vT;
                    }
                }

                var svgText = s.outerSVG();
                document.getElementById("svgSource").value = svgText;
            }



		</script>
	</body>
</html>
